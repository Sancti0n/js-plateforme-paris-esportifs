
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `bets` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/library"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model bets
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type betsModel = runtime.Types.Result.DefaultSelection<Prisma.$betsPayload>

export type AggregateBets = {
  _count: BetsCountAggregateOutputType | null
  _avg: BetsAvgAggregateOutputType | null
  _sum: BetsSumAggregateOutputType | null
  _min: BetsMinAggregateOutputType | null
  _max: BetsMaxAggregateOutputType | null
}

export type BetsAvgAggregateOutputType = {
  amount: runtime.Decimal | null
  odds: runtime.Decimal | null
  potential_payout: runtime.Decimal | null
}

export type BetsSumAggregateOutputType = {
  amount: runtime.Decimal | null
  odds: runtime.Decimal | null
  potential_payout: runtime.Decimal | null
}

export type BetsMinAggregateOutputType = {
  id: string | null
  user_id: string | null
  match_id: string | null
  team_id: string | null
  amount: runtime.Decimal | null
  odds: runtime.Decimal | null
  potential_payout: runtime.Decimal | null
  status: string | null
  placed_at: Date | null
}

export type BetsMaxAggregateOutputType = {
  id: string | null
  user_id: string | null
  match_id: string | null
  team_id: string | null
  amount: runtime.Decimal | null
  odds: runtime.Decimal | null
  potential_payout: runtime.Decimal | null
  status: string | null
  placed_at: Date | null
}

export type BetsCountAggregateOutputType = {
  id: number
  user_id: number
  match_id: number
  team_id: number
  amount: number
  odds: number
  potential_payout: number
  status: number
  placed_at: number
  _all: number
}


export type BetsAvgAggregateInputType = {
  amount?: true
  odds?: true
  potential_payout?: true
}

export type BetsSumAggregateInputType = {
  amount?: true
  odds?: true
  potential_payout?: true
}

export type BetsMinAggregateInputType = {
  id?: true
  user_id?: true
  match_id?: true
  team_id?: true
  amount?: true
  odds?: true
  potential_payout?: true
  status?: true
  placed_at?: true
}

export type BetsMaxAggregateInputType = {
  id?: true
  user_id?: true
  match_id?: true
  team_id?: true
  amount?: true
  odds?: true
  potential_payout?: true
  status?: true
  placed_at?: true
}

export type BetsCountAggregateInputType = {
  id?: true
  user_id?: true
  match_id?: true
  team_id?: true
  amount?: true
  odds?: true
  potential_payout?: true
  status?: true
  placed_at?: true
  _all?: true
}

export type BetsAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which bets to aggregate.
   */
  where?: Prisma.betsWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of bets to fetch.
   */
  orderBy?: Prisma.betsOrderByWithRelationInput | Prisma.betsOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.betsWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` bets from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` bets.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned bets
  **/
  _count?: true | BetsCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: BetsAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: BetsSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: BetsMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: BetsMaxAggregateInputType
}

export type GetBetsAggregateType<T extends BetsAggregateArgs> = {
      [P in keyof T & keyof AggregateBets]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateBets[P]>
    : Prisma.GetScalarType<T[P], AggregateBets[P]>
}




export type betsGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.betsWhereInput
  orderBy?: Prisma.betsOrderByWithAggregationInput | Prisma.betsOrderByWithAggregationInput[]
  by: Prisma.BetsScalarFieldEnum[] | Prisma.BetsScalarFieldEnum
  having?: Prisma.betsScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: BetsCountAggregateInputType | true
  _avg?: BetsAvgAggregateInputType
  _sum?: BetsSumAggregateInputType
  _min?: BetsMinAggregateInputType
  _max?: BetsMaxAggregateInputType
}

export type BetsGroupByOutputType = {
  id: string
  user_id: string | null
  match_id: string | null
  team_id: string | null
  amount: runtime.Decimal
  odds: runtime.Decimal
  potential_payout: runtime.Decimal
  status: string | null
  placed_at: Date | null
  _count: BetsCountAggregateOutputType | null
  _avg: BetsAvgAggregateOutputType | null
  _sum: BetsSumAggregateOutputType | null
  _min: BetsMinAggregateOutputType | null
  _max: BetsMaxAggregateOutputType | null
}

type GetBetsGroupByPayload<T extends betsGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<BetsGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof BetsGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], BetsGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], BetsGroupByOutputType[P]>
      }
    >
  >



export type betsWhereInput = {
  AND?: Prisma.betsWhereInput | Prisma.betsWhereInput[]
  OR?: Prisma.betsWhereInput[]
  NOT?: Prisma.betsWhereInput | Prisma.betsWhereInput[]
  id?: Prisma.UuidFilter<"bets"> | string
  user_id?: Prisma.UuidNullableFilter<"bets"> | string | null
  match_id?: Prisma.UuidNullableFilter<"bets"> | string | null
  team_id?: Prisma.UuidNullableFilter<"bets"> | string | null
  amount?: Prisma.DecimalFilter<"bets"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  odds?: Prisma.DecimalFilter<"bets"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  potential_payout?: Prisma.DecimalFilter<"bets"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  status?: Prisma.StringNullableFilter<"bets"> | string | null
  placed_at?: Prisma.DateTimeNullableFilter<"bets"> | Date | string | null
  matches?: Prisma.XOR<Prisma.MatchesNullableScalarRelationFilter, Prisma.matchesWhereInput> | null
  teams?: Prisma.XOR<Prisma.TeamsNullableScalarRelationFilter, Prisma.teamsWhereInput> | null
  users?: Prisma.XOR<Prisma.UsersNullableScalarRelationFilter, Prisma.usersWhereInput> | null
}

export type betsOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  user_id?: Prisma.SortOrderInput | Prisma.SortOrder
  match_id?: Prisma.SortOrderInput | Prisma.SortOrder
  team_id?: Prisma.SortOrderInput | Prisma.SortOrder
  amount?: Prisma.SortOrder
  odds?: Prisma.SortOrder
  potential_payout?: Prisma.SortOrder
  status?: Prisma.SortOrderInput | Prisma.SortOrder
  placed_at?: Prisma.SortOrderInput | Prisma.SortOrder
  matches?: Prisma.matchesOrderByWithRelationInput
  teams?: Prisma.teamsOrderByWithRelationInput
  users?: Prisma.usersOrderByWithRelationInput
}

export type betsWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  AND?: Prisma.betsWhereInput | Prisma.betsWhereInput[]
  OR?: Prisma.betsWhereInput[]
  NOT?: Prisma.betsWhereInput | Prisma.betsWhereInput[]
  user_id?: Prisma.UuidNullableFilter<"bets"> | string | null
  match_id?: Prisma.UuidNullableFilter<"bets"> | string | null
  team_id?: Prisma.UuidNullableFilter<"bets"> | string | null
  amount?: Prisma.DecimalFilter<"bets"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  odds?: Prisma.DecimalFilter<"bets"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  potential_payout?: Prisma.DecimalFilter<"bets"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  status?: Prisma.StringNullableFilter<"bets"> | string | null
  placed_at?: Prisma.DateTimeNullableFilter<"bets"> | Date | string | null
  matches?: Prisma.XOR<Prisma.MatchesNullableScalarRelationFilter, Prisma.matchesWhereInput> | null
  teams?: Prisma.XOR<Prisma.TeamsNullableScalarRelationFilter, Prisma.teamsWhereInput> | null
  users?: Prisma.XOR<Prisma.UsersNullableScalarRelationFilter, Prisma.usersWhereInput> | null
}, "id">

export type betsOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  user_id?: Prisma.SortOrderInput | Prisma.SortOrder
  match_id?: Prisma.SortOrderInput | Prisma.SortOrder
  team_id?: Prisma.SortOrderInput | Prisma.SortOrder
  amount?: Prisma.SortOrder
  odds?: Prisma.SortOrder
  potential_payout?: Prisma.SortOrder
  status?: Prisma.SortOrderInput | Prisma.SortOrder
  placed_at?: Prisma.SortOrderInput | Prisma.SortOrder
  _count?: Prisma.betsCountOrderByAggregateInput
  _avg?: Prisma.betsAvgOrderByAggregateInput
  _max?: Prisma.betsMaxOrderByAggregateInput
  _min?: Prisma.betsMinOrderByAggregateInput
  _sum?: Prisma.betsSumOrderByAggregateInput
}

export type betsScalarWhereWithAggregatesInput = {
  AND?: Prisma.betsScalarWhereWithAggregatesInput | Prisma.betsScalarWhereWithAggregatesInput[]
  OR?: Prisma.betsScalarWhereWithAggregatesInput[]
  NOT?: Prisma.betsScalarWhereWithAggregatesInput | Prisma.betsScalarWhereWithAggregatesInput[]
  id?: Prisma.UuidWithAggregatesFilter<"bets"> | string
  user_id?: Prisma.UuidNullableWithAggregatesFilter<"bets"> | string | null
  match_id?: Prisma.UuidNullableWithAggregatesFilter<"bets"> | string | null
  team_id?: Prisma.UuidNullableWithAggregatesFilter<"bets"> | string | null
  amount?: Prisma.DecimalWithAggregatesFilter<"bets"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  odds?: Prisma.DecimalWithAggregatesFilter<"bets"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  potential_payout?: Prisma.DecimalWithAggregatesFilter<"bets"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  status?: Prisma.StringNullableWithAggregatesFilter<"bets"> | string | null
  placed_at?: Prisma.DateTimeNullableWithAggregatesFilter<"bets"> | Date | string | null
}

export type betsCreateInput = {
  id?: string
  amount: runtime.Decimal | runtime.DecimalJsLike | number | string
  odds: runtime.Decimal | runtime.DecimalJsLike | number | string
  potential_payout: runtime.Decimal | runtime.DecimalJsLike | number | string
  status?: string | null
  placed_at?: Date | string | null
  matches?: Prisma.matchesCreateNestedOneWithoutBetsInput
  teams?: Prisma.teamsCreateNestedOneWithoutBetsInput
  users?: Prisma.usersCreateNestedOneWithoutBetsInput
}

export type betsUncheckedCreateInput = {
  id?: string
  user_id?: string | null
  match_id?: string | null
  team_id?: string | null
  amount: runtime.Decimal | runtime.DecimalJsLike | number | string
  odds: runtime.Decimal | runtime.DecimalJsLike | number | string
  potential_payout: runtime.Decimal | runtime.DecimalJsLike | number | string
  status?: string | null
  placed_at?: Date | string | null
}

export type betsUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  amount?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  odds?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  potential_payout?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  status?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  placed_at?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  matches?: Prisma.matchesUpdateOneWithoutBetsNestedInput
  teams?: Prisma.teamsUpdateOneWithoutBetsNestedInput
  users?: Prisma.usersUpdateOneWithoutBetsNestedInput
}

export type betsUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  user_id?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  match_id?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  team_id?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  amount?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  odds?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  potential_payout?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  status?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  placed_at?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
}

export type betsCreateManyInput = {
  id?: string
  user_id?: string | null
  match_id?: string | null
  team_id?: string | null
  amount: runtime.Decimal | runtime.DecimalJsLike | number | string
  odds: runtime.Decimal | runtime.DecimalJsLike | number | string
  potential_payout: runtime.Decimal | runtime.DecimalJsLike | number | string
  status?: string | null
  placed_at?: Date | string | null
}

export type betsUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  amount?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  odds?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  potential_payout?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  status?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  placed_at?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
}

export type betsUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  user_id?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  match_id?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  team_id?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  amount?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  odds?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  potential_payout?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  status?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  placed_at?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
}

export type betsCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  user_id?: Prisma.SortOrder
  match_id?: Prisma.SortOrder
  team_id?: Prisma.SortOrder
  amount?: Prisma.SortOrder
  odds?: Prisma.SortOrder
  potential_payout?: Prisma.SortOrder
  status?: Prisma.SortOrder
  placed_at?: Prisma.SortOrder
}

export type betsAvgOrderByAggregateInput = {
  amount?: Prisma.SortOrder
  odds?: Prisma.SortOrder
  potential_payout?: Prisma.SortOrder
}

export type betsMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  user_id?: Prisma.SortOrder
  match_id?: Prisma.SortOrder
  team_id?: Prisma.SortOrder
  amount?: Prisma.SortOrder
  odds?: Prisma.SortOrder
  potential_payout?: Prisma.SortOrder
  status?: Prisma.SortOrder
  placed_at?: Prisma.SortOrder
}

export type betsMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  user_id?: Prisma.SortOrder
  match_id?: Prisma.SortOrder
  team_id?: Prisma.SortOrder
  amount?: Prisma.SortOrder
  odds?: Prisma.SortOrder
  potential_payout?: Prisma.SortOrder
  status?: Prisma.SortOrder
  placed_at?: Prisma.SortOrder
}

export type betsSumOrderByAggregateInput = {
  amount?: Prisma.SortOrder
  odds?: Prisma.SortOrder
  potential_payout?: Prisma.SortOrder
}

export type BetsListRelationFilter = {
  every?: Prisma.betsWhereInput
  some?: Prisma.betsWhereInput
  none?: Prisma.betsWhereInput
}

export type betsOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type StringFieldUpdateOperationsInput = {
  set?: string
}

export type DecimalFieldUpdateOperationsInput = {
  set?: runtime.Decimal | runtime.DecimalJsLike | number | string
  increment?: runtime.Decimal | runtime.DecimalJsLike | number | string
  decrement?: runtime.Decimal | runtime.DecimalJsLike | number | string
  multiply?: runtime.Decimal | runtime.DecimalJsLike | number | string
  divide?: runtime.Decimal | runtime.DecimalJsLike | number | string
}

export type NullableStringFieldUpdateOperationsInput = {
  set?: string | null
}

export type NullableDateTimeFieldUpdateOperationsInput = {
  set?: Date | string | null
}

export type betsCreateNestedManyWithoutMatchesInput = {
  create?: Prisma.XOR<Prisma.betsCreateWithoutMatchesInput, Prisma.betsUncheckedCreateWithoutMatchesInput> | Prisma.betsCreateWithoutMatchesInput[] | Prisma.betsUncheckedCreateWithoutMatchesInput[]
  connectOrCreate?: Prisma.betsCreateOrConnectWithoutMatchesInput | Prisma.betsCreateOrConnectWithoutMatchesInput[]
  createMany?: Prisma.betsCreateManyMatchesInputEnvelope
  connect?: Prisma.betsWhereUniqueInput | Prisma.betsWhereUniqueInput[]
}

export type betsUncheckedCreateNestedManyWithoutMatchesInput = {
  create?: Prisma.XOR<Prisma.betsCreateWithoutMatchesInput, Prisma.betsUncheckedCreateWithoutMatchesInput> | Prisma.betsCreateWithoutMatchesInput[] | Prisma.betsUncheckedCreateWithoutMatchesInput[]
  connectOrCreate?: Prisma.betsCreateOrConnectWithoutMatchesInput | Prisma.betsCreateOrConnectWithoutMatchesInput[]
  createMany?: Prisma.betsCreateManyMatchesInputEnvelope
  connect?: Prisma.betsWhereUniqueInput | Prisma.betsWhereUniqueInput[]
}

export type betsUpdateManyWithoutMatchesNestedInput = {
  create?: Prisma.XOR<Prisma.betsCreateWithoutMatchesInput, Prisma.betsUncheckedCreateWithoutMatchesInput> | Prisma.betsCreateWithoutMatchesInput[] | Prisma.betsUncheckedCreateWithoutMatchesInput[]
  connectOrCreate?: Prisma.betsCreateOrConnectWithoutMatchesInput | Prisma.betsCreateOrConnectWithoutMatchesInput[]
  upsert?: Prisma.betsUpsertWithWhereUniqueWithoutMatchesInput | Prisma.betsUpsertWithWhereUniqueWithoutMatchesInput[]
  createMany?: Prisma.betsCreateManyMatchesInputEnvelope
  set?: Prisma.betsWhereUniqueInput | Prisma.betsWhereUniqueInput[]
  disconnect?: Prisma.betsWhereUniqueInput | Prisma.betsWhereUniqueInput[]
  delete?: Prisma.betsWhereUniqueInput | Prisma.betsWhereUniqueInput[]
  connect?: Prisma.betsWhereUniqueInput | Prisma.betsWhereUniqueInput[]
  update?: Prisma.betsUpdateWithWhereUniqueWithoutMatchesInput | Prisma.betsUpdateWithWhereUniqueWithoutMatchesInput[]
  updateMany?: Prisma.betsUpdateManyWithWhereWithoutMatchesInput | Prisma.betsUpdateManyWithWhereWithoutMatchesInput[]
  deleteMany?: Prisma.betsScalarWhereInput | Prisma.betsScalarWhereInput[]
}

export type betsUncheckedUpdateManyWithoutMatchesNestedInput = {
  create?: Prisma.XOR<Prisma.betsCreateWithoutMatchesInput, Prisma.betsUncheckedCreateWithoutMatchesInput> | Prisma.betsCreateWithoutMatchesInput[] | Prisma.betsUncheckedCreateWithoutMatchesInput[]
  connectOrCreate?: Prisma.betsCreateOrConnectWithoutMatchesInput | Prisma.betsCreateOrConnectWithoutMatchesInput[]
  upsert?: Prisma.betsUpsertWithWhereUniqueWithoutMatchesInput | Prisma.betsUpsertWithWhereUniqueWithoutMatchesInput[]
  createMany?: Prisma.betsCreateManyMatchesInputEnvelope
  set?: Prisma.betsWhereUniqueInput | Prisma.betsWhereUniqueInput[]
  disconnect?: Prisma.betsWhereUniqueInput | Prisma.betsWhereUniqueInput[]
  delete?: Prisma.betsWhereUniqueInput | Prisma.betsWhereUniqueInput[]
  connect?: Prisma.betsWhereUniqueInput | Prisma.betsWhereUniqueInput[]
  update?: Prisma.betsUpdateWithWhereUniqueWithoutMatchesInput | Prisma.betsUpdateWithWhereUniqueWithoutMatchesInput[]
  updateMany?: Prisma.betsUpdateManyWithWhereWithoutMatchesInput | Prisma.betsUpdateManyWithWhereWithoutMatchesInput[]
  deleteMany?: Prisma.betsScalarWhereInput | Prisma.betsScalarWhereInput[]
}

export type betsCreateNestedManyWithoutTeamsInput = {
  create?: Prisma.XOR<Prisma.betsCreateWithoutTeamsInput, Prisma.betsUncheckedCreateWithoutTeamsInput> | Prisma.betsCreateWithoutTeamsInput[] | Prisma.betsUncheckedCreateWithoutTeamsInput[]
  connectOrCreate?: Prisma.betsCreateOrConnectWithoutTeamsInput | Prisma.betsCreateOrConnectWithoutTeamsInput[]
  createMany?: Prisma.betsCreateManyTeamsInputEnvelope
  connect?: Prisma.betsWhereUniqueInput | Prisma.betsWhereUniqueInput[]
}

export type betsUncheckedCreateNestedManyWithoutTeamsInput = {
  create?: Prisma.XOR<Prisma.betsCreateWithoutTeamsInput, Prisma.betsUncheckedCreateWithoutTeamsInput> | Prisma.betsCreateWithoutTeamsInput[] | Prisma.betsUncheckedCreateWithoutTeamsInput[]
  connectOrCreate?: Prisma.betsCreateOrConnectWithoutTeamsInput | Prisma.betsCreateOrConnectWithoutTeamsInput[]
  createMany?: Prisma.betsCreateManyTeamsInputEnvelope
  connect?: Prisma.betsWhereUniqueInput | Prisma.betsWhereUniqueInput[]
}

export type betsUpdateManyWithoutTeamsNestedInput = {
  create?: Prisma.XOR<Prisma.betsCreateWithoutTeamsInput, Prisma.betsUncheckedCreateWithoutTeamsInput> | Prisma.betsCreateWithoutTeamsInput[] | Prisma.betsUncheckedCreateWithoutTeamsInput[]
  connectOrCreate?: Prisma.betsCreateOrConnectWithoutTeamsInput | Prisma.betsCreateOrConnectWithoutTeamsInput[]
  upsert?: Prisma.betsUpsertWithWhereUniqueWithoutTeamsInput | Prisma.betsUpsertWithWhereUniqueWithoutTeamsInput[]
  createMany?: Prisma.betsCreateManyTeamsInputEnvelope
  set?: Prisma.betsWhereUniqueInput | Prisma.betsWhereUniqueInput[]
  disconnect?: Prisma.betsWhereUniqueInput | Prisma.betsWhereUniqueInput[]
  delete?: Prisma.betsWhereUniqueInput | Prisma.betsWhereUniqueInput[]
  connect?: Prisma.betsWhereUniqueInput | Prisma.betsWhereUniqueInput[]
  update?: Prisma.betsUpdateWithWhereUniqueWithoutTeamsInput | Prisma.betsUpdateWithWhereUniqueWithoutTeamsInput[]
  updateMany?: Prisma.betsUpdateManyWithWhereWithoutTeamsInput | Prisma.betsUpdateManyWithWhereWithoutTeamsInput[]
  deleteMany?: Prisma.betsScalarWhereInput | Prisma.betsScalarWhereInput[]
}

export type betsUncheckedUpdateManyWithoutTeamsNestedInput = {
  create?: Prisma.XOR<Prisma.betsCreateWithoutTeamsInput, Prisma.betsUncheckedCreateWithoutTeamsInput> | Prisma.betsCreateWithoutTeamsInput[] | Prisma.betsUncheckedCreateWithoutTeamsInput[]
  connectOrCreate?: Prisma.betsCreateOrConnectWithoutTeamsInput | Prisma.betsCreateOrConnectWithoutTeamsInput[]
  upsert?: Prisma.betsUpsertWithWhereUniqueWithoutTeamsInput | Prisma.betsUpsertWithWhereUniqueWithoutTeamsInput[]
  createMany?: Prisma.betsCreateManyTeamsInputEnvelope
  set?: Prisma.betsWhereUniqueInput | Prisma.betsWhereUniqueInput[]
  disconnect?: Prisma.betsWhereUniqueInput | Prisma.betsWhereUniqueInput[]
  delete?: Prisma.betsWhereUniqueInput | Prisma.betsWhereUniqueInput[]
  connect?: Prisma.betsWhereUniqueInput | Prisma.betsWhereUniqueInput[]
  update?: Prisma.betsUpdateWithWhereUniqueWithoutTeamsInput | Prisma.betsUpdateWithWhereUniqueWithoutTeamsInput[]
  updateMany?: Prisma.betsUpdateManyWithWhereWithoutTeamsInput | Prisma.betsUpdateManyWithWhereWithoutTeamsInput[]
  deleteMany?: Prisma.betsScalarWhereInput | Prisma.betsScalarWhereInput[]
}

export type betsCreateNestedManyWithoutUsersInput = {
  create?: Prisma.XOR<Prisma.betsCreateWithoutUsersInput, Prisma.betsUncheckedCreateWithoutUsersInput> | Prisma.betsCreateWithoutUsersInput[] | Prisma.betsUncheckedCreateWithoutUsersInput[]
  connectOrCreate?: Prisma.betsCreateOrConnectWithoutUsersInput | Prisma.betsCreateOrConnectWithoutUsersInput[]
  createMany?: Prisma.betsCreateManyUsersInputEnvelope
  connect?: Prisma.betsWhereUniqueInput | Prisma.betsWhereUniqueInput[]
}

export type betsUncheckedCreateNestedManyWithoutUsersInput = {
  create?: Prisma.XOR<Prisma.betsCreateWithoutUsersInput, Prisma.betsUncheckedCreateWithoutUsersInput> | Prisma.betsCreateWithoutUsersInput[] | Prisma.betsUncheckedCreateWithoutUsersInput[]
  connectOrCreate?: Prisma.betsCreateOrConnectWithoutUsersInput | Prisma.betsCreateOrConnectWithoutUsersInput[]
  createMany?: Prisma.betsCreateManyUsersInputEnvelope
  connect?: Prisma.betsWhereUniqueInput | Prisma.betsWhereUniqueInput[]
}

export type betsUpdateManyWithoutUsersNestedInput = {
  create?: Prisma.XOR<Prisma.betsCreateWithoutUsersInput, Prisma.betsUncheckedCreateWithoutUsersInput> | Prisma.betsCreateWithoutUsersInput[] | Prisma.betsUncheckedCreateWithoutUsersInput[]
  connectOrCreate?: Prisma.betsCreateOrConnectWithoutUsersInput | Prisma.betsCreateOrConnectWithoutUsersInput[]
  upsert?: Prisma.betsUpsertWithWhereUniqueWithoutUsersInput | Prisma.betsUpsertWithWhereUniqueWithoutUsersInput[]
  createMany?: Prisma.betsCreateManyUsersInputEnvelope
  set?: Prisma.betsWhereUniqueInput | Prisma.betsWhereUniqueInput[]
  disconnect?: Prisma.betsWhereUniqueInput | Prisma.betsWhereUniqueInput[]
  delete?: Prisma.betsWhereUniqueInput | Prisma.betsWhereUniqueInput[]
  connect?: Prisma.betsWhereUniqueInput | Prisma.betsWhereUniqueInput[]
  update?: Prisma.betsUpdateWithWhereUniqueWithoutUsersInput | Prisma.betsUpdateWithWhereUniqueWithoutUsersInput[]
  updateMany?: Prisma.betsUpdateManyWithWhereWithoutUsersInput | Prisma.betsUpdateManyWithWhereWithoutUsersInput[]
  deleteMany?: Prisma.betsScalarWhereInput | Prisma.betsScalarWhereInput[]
}

export type betsUncheckedUpdateManyWithoutUsersNestedInput = {
  create?: Prisma.XOR<Prisma.betsCreateWithoutUsersInput, Prisma.betsUncheckedCreateWithoutUsersInput> | Prisma.betsCreateWithoutUsersInput[] | Prisma.betsUncheckedCreateWithoutUsersInput[]
  connectOrCreate?: Prisma.betsCreateOrConnectWithoutUsersInput | Prisma.betsCreateOrConnectWithoutUsersInput[]
  upsert?: Prisma.betsUpsertWithWhereUniqueWithoutUsersInput | Prisma.betsUpsertWithWhereUniqueWithoutUsersInput[]
  createMany?: Prisma.betsCreateManyUsersInputEnvelope
  set?: Prisma.betsWhereUniqueInput | Prisma.betsWhereUniqueInput[]
  disconnect?: Prisma.betsWhereUniqueInput | Prisma.betsWhereUniqueInput[]
  delete?: Prisma.betsWhereUniqueInput | Prisma.betsWhereUniqueInput[]
  connect?: Prisma.betsWhereUniqueInput | Prisma.betsWhereUniqueInput[]
  update?: Prisma.betsUpdateWithWhereUniqueWithoutUsersInput | Prisma.betsUpdateWithWhereUniqueWithoutUsersInput[]
  updateMany?: Prisma.betsUpdateManyWithWhereWithoutUsersInput | Prisma.betsUpdateManyWithWhereWithoutUsersInput[]
  deleteMany?: Prisma.betsScalarWhereInput | Prisma.betsScalarWhereInput[]
}

export type betsCreateWithoutMatchesInput = {
  id?: string
  amount: runtime.Decimal | runtime.DecimalJsLike | number | string
  odds: runtime.Decimal | runtime.DecimalJsLike | number | string
  potential_payout: runtime.Decimal | runtime.DecimalJsLike | number | string
  status?: string | null
  placed_at?: Date | string | null
  teams?: Prisma.teamsCreateNestedOneWithoutBetsInput
  users?: Prisma.usersCreateNestedOneWithoutBetsInput
}

export type betsUncheckedCreateWithoutMatchesInput = {
  id?: string
  user_id?: string | null
  team_id?: string | null
  amount: runtime.Decimal | runtime.DecimalJsLike | number | string
  odds: runtime.Decimal | runtime.DecimalJsLike | number | string
  potential_payout: runtime.Decimal | runtime.DecimalJsLike | number | string
  status?: string | null
  placed_at?: Date | string | null
}

export type betsCreateOrConnectWithoutMatchesInput = {
  where: Prisma.betsWhereUniqueInput
  create: Prisma.XOR<Prisma.betsCreateWithoutMatchesInput, Prisma.betsUncheckedCreateWithoutMatchesInput>
}

export type betsCreateManyMatchesInputEnvelope = {
  data: Prisma.betsCreateManyMatchesInput | Prisma.betsCreateManyMatchesInput[]
  skipDuplicates?: boolean
}

export type betsUpsertWithWhereUniqueWithoutMatchesInput = {
  where: Prisma.betsWhereUniqueInput
  update: Prisma.XOR<Prisma.betsUpdateWithoutMatchesInput, Prisma.betsUncheckedUpdateWithoutMatchesInput>
  create: Prisma.XOR<Prisma.betsCreateWithoutMatchesInput, Prisma.betsUncheckedCreateWithoutMatchesInput>
}

export type betsUpdateWithWhereUniqueWithoutMatchesInput = {
  where: Prisma.betsWhereUniqueInput
  data: Prisma.XOR<Prisma.betsUpdateWithoutMatchesInput, Prisma.betsUncheckedUpdateWithoutMatchesInput>
}

export type betsUpdateManyWithWhereWithoutMatchesInput = {
  where: Prisma.betsScalarWhereInput
  data: Prisma.XOR<Prisma.betsUpdateManyMutationInput, Prisma.betsUncheckedUpdateManyWithoutMatchesInput>
}

export type betsScalarWhereInput = {
  AND?: Prisma.betsScalarWhereInput | Prisma.betsScalarWhereInput[]
  OR?: Prisma.betsScalarWhereInput[]
  NOT?: Prisma.betsScalarWhereInput | Prisma.betsScalarWhereInput[]
  id?: Prisma.UuidFilter<"bets"> | string
  user_id?: Prisma.UuidNullableFilter<"bets"> | string | null
  match_id?: Prisma.UuidNullableFilter<"bets"> | string | null
  team_id?: Prisma.UuidNullableFilter<"bets"> | string | null
  amount?: Prisma.DecimalFilter<"bets"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  odds?: Prisma.DecimalFilter<"bets"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  potential_payout?: Prisma.DecimalFilter<"bets"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  status?: Prisma.StringNullableFilter<"bets"> | string | null
  placed_at?: Prisma.DateTimeNullableFilter<"bets"> | Date | string | null
}

export type betsCreateWithoutTeamsInput = {
  id?: string
  amount: runtime.Decimal | runtime.DecimalJsLike | number | string
  odds: runtime.Decimal | runtime.DecimalJsLike | number | string
  potential_payout: runtime.Decimal | runtime.DecimalJsLike | number | string
  status?: string | null
  placed_at?: Date | string | null
  matches?: Prisma.matchesCreateNestedOneWithoutBetsInput
  users?: Prisma.usersCreateNestedOneWithoutBetsInput
}

export type betsUncheckedCreateWithoutTeamsInput = {
  id?: string
  user_id?: string | null
  match_id?: string | null
  amount: runtime.Decimal | runtime.DecimalJsLike | number | string
  odds: runtime.Decimal | runtime.DecimalJsLike | number | string
  potential_payout: runtime.Decimal | runtime.DecimalJsLike | number | string
  status?: string | null
  placed_at?: Date | string | null
}

export type betsCreateOrConnectWithoutTeamsInput = {
  where: Prisma.betsWhereUniqueInput
  create: Prisma.XOR<Prisma.betsCreateWithoutTeamsInput, Prisma.betsUncheckedCreateWithoutTeamsInput>
}

export type betsCreateManyTeamsInputEnvelope = {
  data: Prisma.betsCreateManyTeamsInput | Prisma.betsCreateManyTeamsInput[]
  skipDuplicates?: boolean
}

export type betsUpsertWithWhereUniqueWithoutTeamsInput = {
  where: Prisma.betsWhereUniqueInput
  update: Prisma.XOR<Prisma.betsUpdateWithoutTeamsInput, Prisma.betsUncheckedUpdateWithoutTeamsInput>
  create: Prisma.XOR<Prisma.betsCreateWithoutTeamsInput, Prisma.betsUncheckedCreateWithoutTeamsInput>
}

export type betsUpdateWithWhereUniqueWithoutTeamsInput = {
  where: Prisma.betsWhereUniqueInput
  data: Prisma.XOR<Prisma.betsUpdateWithoutTeamsInput, Prisma.betsUncheckedUpdateWithoutTeamsInput>
}

export type betsUpdateManyWithWhereWithoutTeamsInput = {
  where: Prisma.betsScalarWhereInput
  data: Prisma.XOR<Prisma.betsUpdateManyMutationInput, Prisma.betsUncheckedUpdateManyWithoutTeamsInput>
}

export type betsCreateWithoutUsersInput = {
  id?: string
  amount: runtime.Decimal | runtime.DecimalJsLike | number | string
  odds: runtime.Decimal | runtime.DecimalJsLike | number | string
  potential_payout: runtime.Decimal | runtime.DecimalJsLike | number | string
  status?: string | null
  placed_at?: Date | string | null
  matches?: Prisma.matchesCreateNestedOneWithoutBetsInput
  teams?: Prisma.teamsCreateNestedOneWithoutBetsInput
}

export type betsUncheckedCreateWithoutUsersInput = {
  id?: string
  match_id?: string | null
  team_id?: string | null
  amount: runtime.Decimal | runtime.DecimalJsLike | number | string
  odds: runtime.Decimal | runtime.DecimalJsLike | number | string
  potential_payout: runtime.Decimal | runtime.DecimalJsLike | number | string
  status?: string | null
  placed_at?: Date | string | null
}

export type betsCreateOrConnectWithoutUsersInput = {
  where: Prisma.betsWhereUniqueInput
  create: Prisma.XOR<Prisma.betsCreateWithoutUsersInput, Prisma.betsUncheckedCreateWithoutUsersInput>
}

export type betsCreateManyUsersInputEnvelope = {
  data: Prisma.betsCreateManyUsersInput | Prisma.betsCreateManyUsersInput[]
  skipDuplicates?: boolean
}

export type betsUpsertWithWhereUniqueWithoutUsersInput = {
  where: Prisma.betsWhereUniqueInput
  update: Prisma.XOR<Prisma.betsUpdateWithoutUsersInput, Prisma.betsUncheckedUpdateWithoutUsersInput>
  create: Prisma.XOR<Prisma.betsCreateWithoutUsersInput, Prisma.betsUncheckedCreateWithoutUsersInput>
}

export type betsUpdateWithWhereUniqueWithoutUsersInput = {
  where: Prisma.betsWhereUniqueInput
  data: Prisma.XOR<Prisma.betsUpdateWithoutUsersInput, Prisma.betsUncheckedUpdateWithoutUsersInput>
}

export type betsUpdateManyWithWhereWithoutUsersInput = {
  where: Prisma.betsScalarWhereInput
  data: Prisma.XOR<Prisma.betsUpdateManyMutationInput, Prisma.betsUncheckedUpdateManyWithoutUsersInput>
}

export type betsCreateManyMatchesInput = {
  id?: string
  user_id?: string | null
  team_id?: string | null
  amount: runtime.Decimal | runtime.DecimalJsLike | number | string
  odds: runtime.Decimal | runtime.DecimalJsLike | number | string
  potential_payout: runtime.Decimal | runtime.DecimalJsLike | number | string
  status?: string | null
  placed_at?: Date | string | null
}

export type betsUpdateWithoutMatchesInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  amount?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  odds?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  potential_payout?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  status?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  placed_at?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  teams?: Prisma.teamsUpdateOneWithoutBetsNestedInput
  users?: Prisma.usersUpdateOneWithoutBetsNestedInput
}

export type betsUncheckedUpdateWithoutMatchesInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  user_id?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  team_id?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  amount?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  odds?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  potential_payout?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  status?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  placed_at?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
}

export type betsUncheckedUpdateManyWithoutMatchesInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  user_id?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  team_id?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  amount?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  odds?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  potential_payout?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  status?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  placed_at?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
}

export type betsCreateManyTeamsInput = {
  id?: string
  user_id?: string | null
  match_id?: string | null
  amount: runtime.Decimal | runtime.DecimalJsLike | number | string
  odds: runtime.Decimal | runtime.DecimalJsLike | number | string
  potential_payout: runtime.Decimal | runtime.DecimalJsLike | number | string
  status?: string | null
  placed_at?: Date | string | null
}

export type betsUpdateWithoutTeamsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  amount?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  odds?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  potential_payout?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  status?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  placed_at?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  matches?: Prisma.matchesUpdateOneWithoutBetsNestedInput
  users?: Prisma.usersUpdateOneWithoutBetsNestedInput
}

export type betsUncheckedUpdateWithoutTeamsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  user_id?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  match_id?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  amount?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  odds?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  potential_payout?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  status?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  placed_at?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
}

export type betsUncheckedUpdateManyWithoutTeamsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  user_id?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  match_id?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  amount?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  odds?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  potential_payout?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  status?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  placed_at?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
}

export type betsCreateManyUsersInput = {
  id?: string
  match_id?: string | null
  team_id?: string | null
  amount: runtime.Decimal | runtime.DecimalJsLike | number | string
  odds: runtime.Decimal | runtime.DecimalJsLike | number | string
  potential_payout: runtime.Decimal | runtime.DecimalJsLike | number | string
  status?: string | null
  placed_at?: Date | string | null
}

export type betsUpdateWithoutUsersInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  amount?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  odds?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  potential_payout?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  status?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  placed_at?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  matches?: Prisma.matchesUpdateOneWithoutBetsNestedInput
  teams?: Prisma.teamsUpdateOneWithoutBetsNestedInput
}

export type betsUncheckedUpdateWithoutUsersInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  match_id?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  team_id?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  amount?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  odds?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  potential_payout?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  status?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  placed_at?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
}

export type betsUncheckedUpdateManyWithoutUsersInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  match_id?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  team_id?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  amount?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  odds?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  potential_payout?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  status?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  placed_at?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
}



export type betsSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  user_id?: boolean
  match_id?: boolean
  team_id?: boolean
  amount?: boolean
  odds?: boolean
  potential_payout?: boolean
  status?: boolean
  placed_at?: boolean
  matches?: boolean | Prisma.bets$matchesArgs<ExtArgs>
  teams?: boolean | Prisma.bets$teamsArgs<ExtArgs>
  users?: boolean | Prisma.bets$usersArgs<ExtArgs>
}, ExtArgs["result"]["bets"]>

export type betsSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  user_id?: boolean
  match_id?: boolean
  team_id?: boolean
  amount?: boolean
  odds?: boolean
  potential_payout?: boolean
  status?: boolean
  placed_at?: boolean
  matches?: boolean | Prisma.bets$matchesArgs<ExtArgs>
  teams?: boolean | Prisma.bets$teamsArgs<ExtArgs>
  users?: boolean | Prisma.bets$usersArgs<ExtArgs>
}, ExtArgs["result"]["bets"]>

export type betsSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  user_id?: boolean
  match_id?: boolean
  team_id?: boolean
  amount?: boolean
  odds?: boolean
  potential_payout?: boolean
  status?: boolean
  placed_at?: boolean
  matches?: boolean | Prisma.bets$matchesArgs<ExtArgs>
  teams?: boolean | Prisma.bets$teamsArgs<ExtArgs>
  users?: boolean | Prisma.bets$usersArgs<ExtArgs>
}, ExtArgs["result"]["bets"]>

export type betsSelectScalar = {
  id?: boolean
  user_id?: boolean
  match_id?: boolean
  team_id?: boolean
  amount?: boolean
  odds?: boolean
  potential_payout?: boolean
  status?: boolean
  placed_at?: boolean
}

export type betsOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "user_id" | "match_id" | "team_id" | "amount" | "odds" | "potential_payout" | "status" | "placed_at", ExtArgs["result"]["bets"]>
export type betsInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  matches?: boolean | Prisma.bets$matchesArgs<ExtArgs>
  teams?: boolean | Prisma.bets$teamsArgs<ExtArgs>
  users?: boolean | Prisma.bets$usersArgs<ExtArgs>
}
export type betsIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  matches?: boolean | Prisma.bets$matchesArgs<ExtArgs>
  teams?: boolean | Prisma.bets$teamsArgs<ExtArgs>
  users?: boolean | Prisma.bets$usersArgs<ExtArgs>
}
export type betsIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  matches?: boolean | Prisma.bets$matchesArgs<ExtArgs>
  teams?: boolean | Prisma.bets$teamsArgs<ExtArgs>
  users?: boolean | Prisma.bets$usersArgs<ExtArgs>
}

export type $betsPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "bets"
  objects: {
    matches: Prisma.$matchesPayload<ExtArgs> | null
    teams: Prisma.$teamsPayload<ExtArgs> | null
    users: Prisma.$usersPayload<ExtArgs> | null
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    user_id: string | null
    match_id: string | null
    team_id: string | null
    amount: runtime.Decimal
    odds: runtime.Decimal
    potential_payout: runtime.Decimal
    status: string | null
    placed_at: Date | null
  }, ExtArgs["result"]["bets"]>
  composites: {}
}

export type betsGetPayload<S extends boolean | null | undefined | betsDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$betsPayload, S>

export type betsCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<betsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: BetsCountAggregateInputType | true
  }

export interface betsDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bets'], meta: { name: 'bets' } }
  /**
   * Find zero or one Bets that matches the filter.
   * @param {betsFindUniqueArgs} args - Arguments to find a Bets
   * @example
   * // Get one Bets
   * const bets = await prisma.bets.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends betsFindUniqueArgs>(args: Prisma.SelectSubset<T, betsFindUniqueArgs<ExtArgs>>): Prisma.Prisma__betsClient<runtime.Types.Result.GetResult<Prisma.$betsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one Bets that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {betsFindUniqueOrThrowArgs} args - Arguments to find a Bets
   * @example
   * // Get one Bets
   * const bets = await prisma.bets.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends betsFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, betsFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__betsClient<runtime.Types.Result.GetResult<Prisma.$betsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Bets that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {betsFindFirstArgs} args - Arguments to find a Bets
   * @example
   * // Get one Bets
   * const bets = await prisma.bets.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends betsFindFirstArgs>(args?: Prisma.SelectSubset<T, betsFindFirstArgs<ExtArgs>>): Prisma.Prisma__betsClient<runtime.Types.Result.GetResult<Prisma.$betsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Bets that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {betsFindFirstOrThrowArgs} args - Arguments to find a Bets
   * @example
   * // Get one Bets
   * const bets = await prisma.bets.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends betsFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, betsFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__betsClient<runtime.Types.Result.GetResult<Prisma.$betsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more Bets that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {betsFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Bets
   * const bets = await prisma.bets.findMany()
   * 
   * // Get first 10 Bets
   * const bets = await prisma.bets.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const betsWithIdOnly = await prisma.bets.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends betsFindManyArgs>(args?: Prisma.SelectSubset<T, betsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$betsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a Bets.
   * @param {betsCreateArgs} args - Arguments to create a Bets.
   * @example
   * // Create one Bets
   * const Bets = await prisma.bets.create({
   *   data: {
   *     // ... data to create a Bets
   *   }
   * })
   * 
   */
  create<T extends betsCreateArgs>(args: Prisma.SelectSubset<T, betsCreateArgs<ExtArgs>>): Prisma.Prisma__betsClient<runtime.Types.Result.GetResult<Prisma.$betsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many Bets.
   * @param {betsCreateManyArgs} args - Arguments to create many Bets.
   * @example
   * // Create many Bets
   * const bets = await prisma.bets.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends betsCreateManyArgs>(args?: Prisma.SelectSubset<T, betsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many Bets and returns the data saved in the database.
   * @param {betsCreateManyAndReturnArgs} args - Arguments to create many Bets.
   * @example
   * // Create many Bets
   * const bets = await prisma.bets.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many Bets and only return the `id`
   * const betsWithIdOnly = await prisma.bets.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends betsCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, betsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$betsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a Bets.
   * @param {betsDeleteArgs} args - Arguments to delete one Bets.
   * @example
   * // Delete one Bets
   * const Bets = await prisma.bets.delete({
   *   where: {
   *     // ... filter to delete one Bets
   *   }
   * })
   * 
   */
  delete<T extends betsDeleteArgs>(args: Prisma.SelectSubset<T, betsDeleteArgs<ExtArgs>>): Prisma.Prisma__betsClient<runtime.Types.Result.GetResult<Prisma.$betsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one Bets.
   * @param {betsUpdateArgs} args - Arguments to update one Bets.
   * @example
   * // Update one Bets
   * const bets = await prisma.bets.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends betsUpdateArgs>(args: Prisma.SelectSubset<T, betsUpdateArgs<ExtArgs>>): Prisma.Prisma__betsClient<runtime.Types.Result.GetResult<Prisma.$betsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more Bets.
   * @param {betsDeleteManyArgs} args - Arguments to filter Bets to delete.
   * @example
   * // Delete a few Bets
   * const { count } = await prisma.bets.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends betsDeleteManyArgs>(args?: Prisma.SelectSubset<T, betsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Bets.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {betsUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Bets
   * const bets = await prisma.bets.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends betsUpdateManyArgs>(args: Prisma.SelectSubset<T, betsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Bets and returns the data updated in the database.
   * @param {betsUpdateManyAndReturnArgs} args - Arguments to update many Bets.
   * @example
   * // Update many Bets
   * const bets = await prisma.bets.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more Bets and only return the `id`
   * const betsWithIdOnly = await prisma.bets.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends betsUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, betsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$betsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one Bets.
   * @param {betsUpsertArgs} args - Arguments to update or create a Bets.
   * @example
   * // Update or create a Bets
   * const bets = await prisma.bets.upsert({
   *   create: {
   *     // ... data to create a Bets
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Bets we want to update
   *   }
   * })
   */
  upsert<T extends betsUpsertArgs>(args: Prisma.SelectSubset<T, betsUpsertArgs<ExtArgs>>): Prisma.Prisma__betsClient<runtime.Types.Result.GetResult<Prisma.$betsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of Bets.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {betsCountArgs} args - Arguments to filter Bets to count.
   * @example
   * // Count the number of Bets
   * const count = await prisma.bets.count({
   *   where: {
   *     // ... the filter for the Bets we want to count
   *   }
   * })
  **/
  count<T extends betsCountArgs>(
    args?: Prisma.Subset<T, betsCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], BetsCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a Bets.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {BetsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends BetsAggregateArgs>(args: Prisma.Subset<T, BetsAggregateArgs>): Prisma.PrismaPromise<GetBetsAggregateType<T>>

  /**
   * Group by Bets.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {betsGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends betsGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: betsGroupByArgs['orderBy'] }
      : { orderBy?: betsGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, betsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBetsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the bets model
 */
readonly fields: betsFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for bets.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__betsClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  matches<T extends Prisma.bets$matchesArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.bets$matchesArgs<ExtArgs>>): Prisma.Prisma__matchesClient<runtime.Types.Result.GetResult<Prisma.$matchesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
  teams<T extends Prisma.bets$teamsArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.bets$teamsArgs<ExtArgs>>): Prisma.Prisma__teamsClient<runtime.Types.Result.GetResult<Prisma.$teamsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
  users<T extends Prisma.bets$usersArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.bets$usersArgs<ExtArgs>>): Prisma.Prisma__usersClient<runtime.Types.Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the bets model
 */
export interface betsFieldRefs {
  readonly id: Prisma.FieldRef<"bets", 'String'>
  readonly user_id: Prisma.FieldRef<"bets", 'String'>
  readonly match_id: Prisma.FieldRef<"bets", 'String'>
  readonly team_id: Prisma.FieldRef<"bets", 'String'>
  readonly amount: Prisma.FieldRef<"bets", 'Decimal'>
  readonly odds: Prisma.FieldRef<"bets", 'Decimal'>
  readonly potential_payout: Prisma.FieldRef<"bets", 'Decimal'>
  readonly status: Prisma.FieldRef<"bets", 'String'>
  readonly placed_at: Prisma.FieldRef<"bets", 'DateTime'>
}
    

// Custom InputTypes
/**
 * bets findUnique
 */
export type betsFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the bets
   */
  select?: Prisma.betsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the bets
   */
  omit?: Prisma.betsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.betsInclude<ExtArgs> | null
  /**
   * Filter, which bets to fetch.
   */
  where: Prisma.betsWhereUniqueInput
}

/**
 * bets findUniqueOrThrow
 */
export type betsFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the bets
   */
  select?: Prisma.betsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the bets
   */
  omit?: Prisma.betsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.betsInclude<ExtArgs> | null
  /**
   * Filter, which bets to fetch.
   */
  where: Prisma.betsWhereUniqueInput
}

/**
 * bets findFirst
 */
export type betsFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the bets
   */
  select?: Prisma.betsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the bets
   */
  omit?: Prisma.betsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.betsInclude<ExtArgs> | null
  /**
   * Filter, which bets to fetch.
   */
  where?: Prisma.betsWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of bets to fetch.
   */
  orderBy?: Prisma.betsOrderByWithRelationInput | Prisma.betsOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for bets.
   */
  cursor?: Prisma.betsWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` bets from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` bets.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of bets.
   */
  distinct?: Prisma.BetsScalarFieldEnum | Prisma.BetsScalarFieldEnum[]
}

/**
 * bets findFirstOrThrow
 */
export type betsFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the bets
   */
  select?: Prisma.betsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the bets
   */
  omit?: Prisma.betsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.betsInclude<ExtArgs> | null
  /**
   * Filter, which bets to fetch.
   */
  where?: Prisma.betsWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of bets to fetch.
   */
  orderBy?: Prisma.betsOrderByWithRelationInput | Prisma.betsOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for bets.
   */
  cursor?: Prisma.betsWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` bets from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` bets.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of bets.
   */
  distinct?: Prisma.BetsScalarFieldEnum | Prisma.BetsScalarFieldEnum[]
}

/**
 * bets findMany
 */
export type betsFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the bets
   */
  select?: Prisma.betsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the bets
   */
  omit?: Prisma.betsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.betsInclude<ExtArgs> | null
  /**
   * Filter, which bets to fetch.
   */
  where?: Prisma.betsWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of bets to fetch.
   */
  orderBy?: Prisma.betsOrderByWithRelationInput | Prisma.betsOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing bets.
   */
  cursor?: Prisma.betsWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` bets from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` bets.
   */
  skip?: number
  distinct?: Prisma.BetsScalarFieldEnum | Prisma.BetsScalarFieldEnum[]
}

/**
 * bets create
 */
export type betsCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the bets
   */
  select?: Prisma.betsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the bets
   */
  omit?: Prisma.betsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.betsInclude<ExtArgs> | null
  /**
   * The data needed to create a bets.
   */
  data: Prisma.XOR<Prisma.betsCreateInput, Prisma.betsUncheckedCreateInput>
}

/**
 * bets createMany
 */
export type betsCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many bets.
   */
  data: Prisma.betsCreateManyInput | Prisma.betsCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * bets createManyAndReturn
 */
export type betsCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the bets
   */
  select?: Prisma.betsSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the bets
   */
  omit?: Prisma.betsOmit<ExtArgs> | null
  /**
   * The data used to create many bets.
   */
  data: Prisma.betsCreateManyInput | Prisma.betsCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.betsIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * bets update
 */
export type betsUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the bets
   */
  select?: Prisma.betsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the bets
   */
  omit?: Prisma.betsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.betsInclude<ExtArgs> | null
  /**
   * The data needed to update a bets.
   */
  data: Prisma.XOR<Prisma.betsUpdateInput, Prisma.betsUncheckedUpdateInput>
  /**
   * Choose, which bets to update.
   */
  where: Prisma.betsWhereUniqueInput
}

/**
 * bets updateMany
 */
export type betsUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update bets.
   */
  data: Prisma.XOR<Prisma.betsUpdateManyMutationInput, Prisma.betsUncheckedUpdateManyInput>
  /**
   * Filter which bets to update
   */
  where?: Prisma.betsWhereInput
  /**
   * Limit how many bets to update.
   */
  limit?: number
}

/**
 * bets updateManyAndReturn
 */
export type betsUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the bets
   */
  select?: Prisma.betsSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the bets
   */
  omit?: Prisma.betsOmit<ExtArgs> | null
  /**
   * The data used to update bets.
   */
  data: Prisma.XOR<Prisma.betsUpdateManyMutationInput, Prisma.betsUncheckedUpdateManyInput>
  /**
   * Filter which bets to update
   */
  where?: Prisma.betsWhereInput
  /**
   * Limit how many bets to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.betsIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * bets upsert
 */
export type betsUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the bets
   */
  select?: Prisma.betsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the bets
   */
  omit?: Prisma.betsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.betsInclude<ExtArgs> | null
  /**
   * The filter to search for the bets to update in case it exists.
   */
  where: Prisma.betsWhereUniqueInput
  /**
   * In case the bets found by the `where` argument doesn't exist, create a new bets with this data.
   */
  create: Prisma.XOR<Prisma.betsCreateInput, Prisma.betsUncheckedCreateInput>
  /**
   * In case the bets was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.betsUpdateInput, Prisma.betsUncheckedUpdateInput>
}

/**
 * bets delete
 */
export type betsDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the bets
   */
  select?: Prisma.betsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the bets
   */
  omit?: Prisma.betsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.betsInclude<ExtArgs> | null
  /**
   * Filter which bets to delete.
   */
  where: Prisma.betsWhereUniqueInput
}

/**
 * bets deleteMany
 */
export type betsDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which bets to delete
   */
  where?: Prisma.betsWhereInput
  /**
   * Limit how many bets to delete.
   */
  limit?: number
}

/**
 * bets.matches
 */
export type bets$matchesArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the matches
   */
  select?: Prisma.matchesSelect<ExtArgs> | null
  /**
   * Omit specific fields from the matches
   */
  omit?: Prisma.matchesOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.matchesInclude<ExtArgs> | null
  where?: Prisma.matchesWhereInput
}

/**
 * bets.teams
 */
export type bets$teamsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the teams
   */
  select?: Prisma.teamsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the teams
   */
  omit?: Prisma.teamsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.teamsInclude<ExtArgs> | null
  where?: Prisma.teamsWhereInput
}

/**
 * bets.users
 */
export type bets$usersArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the users
   */
  select?: Prisma.usersSelect<ExtArgs> | null
  /**
   * Omit specific fields from the users
   */
  omit?: Prisma.usersOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.usersInclude<ExtArgs> | null
  where?: Prisma.usersWhereInput
}

/**
 * bets without action
 */
export type betsDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the bets
   */
  select?: Prisma.betsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the bets
   */
  omit?: Prisma.betsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.betsInclude<ExtArgs> | null
}
